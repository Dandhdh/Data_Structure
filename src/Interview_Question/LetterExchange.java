package Interview_Question;import java.util.ArrayList;import java.util.List;import java.util.Scanner;/** * 字母交换 * * 今日头条编程题 * * 字符串S由小写字母构成，长度为n。定义一种操作，每次都可以挑选字符串中任意的两个相邻字母进行交换。 * 询问在至多交换m次之后，字符串中最多有多少个连续的位置上的字母相同？ * * 输入描述: * 第一行为一个字符串S与一个非负整数m。(1 <= |S| <= 1000, 1 <= m <= 1000000) * * * 输出描述: * 一个非负整数，表示操作之后，连续最长的相同字母数量。 * 示例1 * 输入 * abcbaa 2 * 输出 * 2 * 说明 * 使2个字母a连续出现，至少需要3次操作。即把第1个位置上的a移动到第4个位置。 * 所以在至多操作2次的情况下，最多只能使2个b或2个a连续出现。 *//** * 解题思路： * 参考：https://blog.csdn.net/flushhip/article/details/79416715 * * dp[i][j]表示把pos[i]和pos[j]之间的目标字母移动到一起，形成j - i + 1长度的连续子序列所需要的操作次数； * * 状态转移方程： * dp[i][i + len - 1] = dp[i + 1][i + len - 2] + pos[i + len - 1] - pos[i] - len + 1; * * 依据是|x?a|+|x?b|在什么时候取得最小值。 * 用最小的移动次数把两个目标字母移动到一起的方法就是把两个目标字母都往中间靠，状态转移方程就是根据这个来的， * 先把pos[i + 1] ~ pos[i + len - 2]之间的目标字母移动到一起，这个移动次数就是dp[i + 1][i + len - 2]， * 然后把两个端点pos[i]和pos[i + len -1]处的目标字母往中间靠，所需要的移动次数是pos[i + len - 1] - pos[i] - len + 1。 * * 实现要点： * 1、对所有字母遍历，每次只考虑当前字母，也就是记录当前字母的位置 * 如：假设对于字符'a'，设有集合 post(0,2,4,6,7)，表示字符'a'在字符串的位置的集合 * 2、动态递归 */public class LetterExchange {    private static int[][] dp = new int[1005][1005];    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        String string = sc.next();        char[] str = string.toCharArray();        int n = sc.nextInt();        int ans = 1;        for (char c='a'; c<='z'; c++){            List<Integer> post = new ArrayList<>();            for (int i=0; i<str.length; i++){                if (c==str[i]){                    post.add(i);                }            }            if (post.size()<2){                continue;            }            int ret = 1;            int[][] dp = new int[post.size()][post.size()];            for (int len=2; len<=post.size(); len++){                for (int i=0; i+len-1<post.size(); i++){                    dp[i][i + len - 1] =                            dp[i + 1][i + len - 2]                            + post.get(i + len - 1) - post.get(i) - len + 1;                    if (dp[i][i+len-1]<=n){                        ret = len;                    }                }            }            ans = Math.max(ans,ret);        }        System.out.println(ans);    }}