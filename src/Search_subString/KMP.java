package Search_subString;/** * KMP子字符串查找算法 * * 基本思想： * 当出现不匹配的时候，就能知晓一部分文本的内容（因为在匹配失败之前它们已经和模式相匹配） * 我们可以利用这些信息避免将指针回退到所有这些已知的字符之前 * * 模式指针的回退： * 对于每个字符c，在比较了c和pat.charAt(j)之后，dfa[c][j]表示的是应该和下个文本字符比较的模式字符的位置。 * 在查找中，dfa[txt.charAt(i)][j]是在比较了 * * 参考链接： * https://blog.csdn.net/congduan/article/details/45459963 * https://weijp.github.io/2017/03/19/blogKMPDFA/ */public class KMP {    private String pat;    private int[][] dfa;    /**     * 假设此时匹配到c=txt.charAt(i),此时找到dfa确定该转跳到哪个状态？     *     * 当c与pat.charAt(j)不匹配时，     * 同时说明，txt[i-j…i-1]与pat[0…j-1]是匹配的     * 又因为由上知道，从txt[i-j]位开始，无法与模式完全匹配，所以pat需要右移一位，     * 所以txt[i-j]舍弃，不用再比较，     * 也就是在状态j遇到条件c时要转跳的状态，txt[i-j+1 … i-1] == pat[1 … j-1]     *     * 引入重启状态数组X，X[j]是指正确输入p[1 … j-1]后应该转跳的状态     * 输入p[1…j-1]后，进入的状态就是dfa[c][X[j]]（在X[j]状态时输入c），即dfa[c][j]=dfa[c][X[j]]。     *     * X[j+1]为正确输入p[1…j]后进入的状态，即正确输入p[1…j-1]p[j]后进入的状态，     * 也就是在X[j]状态时输入p[j]时进入的状态，     * 就是dfa[pat.charAt[j]][X[j]]，     * 即递推公式为：X[j+1]=dfa[pat.charAt[j]][X[j]]，而X[0]手动初始化为0。     *     */    // 由模式字符串构造DFA    private KMP(String pat){        this.pat = pat;        int M = pat.length();        int R = 256;        dfa = new int[R][M];        /**         * 初始状态：即在只有匹配到模式第一个字符（pat.charAt(0)）的时候，j才由0变成1         * 否则，其他的都是0         */        dfa[pat.charAt(0)][0] = 1;        // 计算dfa[][j]        // 重启状态X （ dfa[][X] ）        for (int X=0,j=1; j<M; j++){            for (int c = 0; c<R; c++){                // 匹配失败时，回到获取重启状态所在列的值                dfa[c][j] = dfa[c][X];            }            /**             * 本为 dfa[c][j],             * 此处为：dfa[pat.charAt(j)][j]             * 即，当c与pat.charAt(j)相等的时候，j的状态变为j+1（即匹配模式的下一个字符）             */            dfa[pat.charAt(j)][j] = j+1;   // 设置匹配成功情况下的值            // 正确输入p[1…j]后进入的状态（在X[j]状态时输入pat.charAt(j)）            X = dfa[pat.charAt(j)][X];     // 更新重启状态        }    }    // 在txt上模拟DFA的运行    public int search(String txt){        int i,j, N = txt.length(), M = pat.length();        for (i=0, j=0; i<N && j<M; i++){            j = dfa[txt.charAt(i)][j];        }        if (j==M){            return i-M;     // 找到匹配（到达模式字符串的结尾）        }else{            return N ;      // 未找到匹配（到达文本字符串的结尾）        }    }    public static void main(String[] args) {        String pat = "AACAA";        String txt = "AABRAACADBRAACAADABRA";        KMP kmp = new KMP(pat);        System.out.println("text:     "+txt);        int offset = kmp.search(txt);        System.out.print("pattern:  ");        for (int i=0; i<offset; i++){            System.out.print(" ");        }        System.out.println(pat);    }    private static void print(int[][] dfa){        System.out.println("dfa[][]");        for (int[] eles : dfa){            for (int ele : eles){                System.out.print(ele+" ");            }            System.out.println();        }    }}